# 프로그래머스

## 가장 큰 수

[정렬문제]

1. numbers를 문자열 배열로 바꾼다.

2. 해당 문자열을 3배씩 늘린다. 

   Ex) "12" => "121212" // "4" => "444" // "789" => "789789789"

   왜? 22와 221 둘 중에 누가 먼저 앞으로 나와야하는지 결정해야하기 때문이다.
   "222222" vs "221221221" 에서 문자열 비교기 때문에 "22" 가 "221" 보다 우선순위가 높게 된다.

   *3? 해당 조건이 각 숫자가 1000이하 이기 때문에 *3

3. 늘린 문자열끼리 sort를 진행 한 후 그 순서대로 원래 문자열을 이어준다.

4. 이 때 str(int())를 하는 이유는 '0' 이 연속으로 나올 경우 '0' 으로 만들어주기 위해서이다.

### 다른 사람 풀이

~~~python
def solution(numbers):
    numbers = list(map(str, numbers))
    numbers.sort(key=lambda x: x*3, reverse=True)
    return str(int(''.join(numbers)))
~~~

~~~python
import functools

def comparator(a,b):
    t1 = a+b
    t2 = b+a
    return (int(t1) > int(t2)) - (int(t1) < int(t2)) #  t1이 크다면 1  // t2가 크다면 -1  //  같으면 0

def solution(numbers):
    n = [str(x) for x in numbers]
    n = sorted(n, key=functools.cmp_to_key(comparator),reverse=True)
    answer = str(int(''.join(n)))
    return answer
~~~



## 큰 수 만들기

탐욕법(Greedy) => Stack으로 풀이

1. 스택에 문자 하나씩 input
2. 스택의 top 숫자보다 큰 수가 있으면 스택에서 제거 후 input (k 값이 0보다 클때까지 )
3. if k >0 &  결과가 만들어지면 아래 문장 실행 (stack에 정답 이외의 숫자 남음)

~~~python
    if k != 0:
        stack = stack[:-k]
~~~

~~~
417725842111
-> stack[7,7,5,8,4,2,1,1,1]
~~~



### 다른 사람 풀이

~~~python
def solution(number, k):
    stack = [number[0]]
    for num in number[1:]:
        while len(stack) > 0 and stack[-1] < num and k > 0:
            k -= 1
            stack.pop()
        stack.append(num)
    if k != 0:
        stack = stack[:-k]
    return ''.join(stack)
~~~

~~~python
def solution(number, k):
    st = []
    for i in range(len(number)):
        while st and k > 0 and st[-1] < number[i]:
            st.pop()
            k -= 1
        st.append(number[i])
    return ''.join(st[:len(st) - k])
~~~



## 더 맵게

힙(heap) 으로 구현

1. 스코빌 지수를 힙에 넣는다.
2. 제일 낮은 스코빌 지수 2개를 꺼내 섞은 후 힙에 넣는다.
3. 이를 반복한다.

~~~python
import heapq
def solution(scoville, K):
    answer = 0
    h = []
    for food in scoville:
        heapq.heappush(h,food)
        
    while h[0] < K:
        if len(h) < 2:
            return -1
        first = heapq.heappop(h)
        second = heapq.heappop(h)
        cal = first + second*2
        heapq.heappush(h,cal)
        answer += 1

    return answer
~~~



